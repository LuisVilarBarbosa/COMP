package tuner;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Parser {
    private ArrayList<String> codeLines;
    private ArrayList<Integer> pragmaIndexes;
    private ArrayList<Node> syntacticAnalysisTrees;

    public Parser(BufferedReader bufferedReader) throws Exception {
        this.codeLines = getLines(bufferedReader);
        this.pragmaIndexes = findPragmas(this.codeLines);
        this.syntacticAnalysisTrees = generateSyntacticAnalysisTrees(this.codeLines, this.pragmaIndexes);
    }

    public ArrayList<String> getCodeLines() {
        return codeLines;
    }

    public ArrayList<Integer> getPragmaIndexes() {
        return pragmaIndexes;
    }

    public ArrayList<Node> getSyntacticAnalysisTrees() {
        return syntacticAnalysisTrees;
    }

    private ArrayList<String> getLines(BufferedReader bufferedReader) throws IOException {
        ArrayList<String> lines = new ArrayList<>();
        String str;
        while ((str = bufferedReader.readLine()) != null)
            lines.add(str);
        return lines;
    }

    // Comments started by "//" are ignored by the regular expression.
    private ArrayList<Integer> findPragmas(ArrayList<String> codeLines) throws Exception {
        ArrayList<Integer> pragmaIndexes = new ArrayList<>();
        Pattern pattern = Pattern.compile("(?:(?!//).)*#pragma[\t ]+tuner.*");
        boolean ignoreLines = false;
        for (int i = 0; i < codeLines.size(); i++) {
            String line = codeLines.get(i);
            if (ignoreLines) {
                // Cannot exist an uncommented pragma.
                if (line.contains("*/"))
                    ignoreLines = false;
            } else {
                Matcher matcher = pattern.matcher(line);
                if (matcher.matches())
                    pragmaIndexes.add(i);
                if (line.contains("/*"))
                    ignoreLines = true;
            }
        }
        if (pragmaIndexes.size() % 2 != 0)
            throw new Exception("Odd number of pragmas. For each clause must exist a start pragma and an end pragma.");
        return pragmaIndexes;
    }

    private ArrayList<Node> generateSyntacticAnalysisTrees(ArrayList<String> codeLines, ArrayList<Integer> pragmaIndexes) throws Exception {
        ArrayList<Node> pragmaTrees = new ArrayList<>();
        for (int i = 0, j = pragmaIndexes.size() - 1; i <= j; i++, j--) {
            Node root = new Node("");
            buildTree(codeLines.get(pragmaIndexes.get(i)), root);
            buildTree(codeLines.get(pragmaIndexes.get(j)), root);
            pragmaTrees.add(root);
        }
        return pragmaTrees;
    }

    private void buildTree(String pragma, Node root) throws Exception {
        Command command = new Command("java", "-cp", "bin", "JJTree.SyntacticAnalyser", pragma);
        command.setStoreOutput(true);
        command.run();

        ArrayList<String> lines = command.getOutputStreamLines();

        if (lines.size() >= 2) {
            if (lines.get(0).startsWith("Encountered") && lines.get(1).startsWith("Was expecting"))
                throw new Exception("Invalid pragma found: " + pragma);
        }

        int indentation = 0;
        Node lastNewNode = root;
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);

            int numTabs = 0;
            while (line.charAt(numTabs) == ' ' && numTabs < line.length())
                numTabs++;

            String info = line.substring(numTabs);

            if (numTabs == indentation) {
                Node parent = root.getParent(lastNewNode);
                if (parent == null)
                    parent = root;
                lastNewNode = addNodeToTree(info, parent);
            } else if (numTabs == indentation - 1) {
                Node parent = root.getParent(lastNewNode);
                Node grandparent = root.getParent(parent);
                lastNewNode = addNodeToTree(info, grandparent);
            } else if (numTabs == indentation + 1) {
                lastNewNode = addNodeToTree(info, lastNewNode);
            } else
                throw new Exception("A problem occurred while loading the tree generated by JJTree.");

            indentation = numTabs;
        }
    }

    private Node addNodeToTree(String info, Node parent) {
        Node n = new Node(info);
        parent.addChild(n);
        return n;
    }
}
